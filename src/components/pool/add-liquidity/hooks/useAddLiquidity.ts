import { ethers } from 'ethers'
import { useState } from 'react'
import { toast } from 'sonner'
import { useAccount, useChainId } from 'wagmi'
import { getUniformDistributionFromBinRange } from '@lb-xyz/sdk-v2'
import { useDexOperations, useTokenBalanceByAddress, createViemClient } from '../../../../dex'
import { getTokensForChain } from '../../../../dex/networkTokens'
import { LiquidityStrategy } from '../StrategySelection'

interface PoolData {
	id: string
	token0: string
	token1: string
	icon0: string
	icon1: string
	tvl: string
	apr: string
	volume24h: string
	fees24h: string
	userLiquidity?: string
	pairAddress?: string
	binStep?: number
	tokenXAddress?: string
	tokenYAddress?: string
}

export const useAddLiquidity = (
	selectedPool: PoolData | null,
	onSuccess?: () => void
) => {
	const { address: userWalletAddress } = useAccount()
	const currentChainId = useChainId()
	const [isPending, setIsPending] = useState(false)
	const [isSuccess, setIsSuccess] = useState(false)
	const [error, setError] = useState<Error | null>(null)
	const [slippageTolerance] = useState(1)

	const { addLiquidity } = useDexOperations()
	
	// üéØ Âä®ÊÄÅËé∑ÂèñtokenÂú∞ÂùÄ
	const getTokenAddress = (symbol: string): string | undefined => {
		const tokens = getTokensForChain(currentChainId)
		const token = tokens.find(t => t.symbol === symbol)
		console.log(`ÔøΩ Finding token address for ${symbol}:`, {
			found: !!token,
			address: token?.address,
			allTokens: tokens.map(t => ({ symbol: t.symbol, address: t.address }))
		})
		return token?.address
	}
	
	// üéØ Á°ÆÂÆöÊúÄÁªàÁöÑtokenÂú∞ÂùÄ
	const finalTokenXAddress = selectedPool?.tokenXAddress || getTokenAddress(selectedPool?.token0 || '')
	const finalTokenYAddress = selectedPool?.tokenYAddress || getTokenAddress(selectedPool?.token1 || '')
	
	// ÔøΩüö® Debug: Log token addresses and pool data
	console.log('üîç useAddLiquidity Debug:', {
		selectedPool: selectedPool,
		originalTokenXAddress: selectedPool?.tokenXAddress,
		originalTokenYAddress: selectedPool?.tokenYAddress,
		finalTokenXAddress: finalTokenXAddress,
		finalTokenYAddress: finalTokenYAddress,
		userWalletAddress: userWalletAddress,
		poolToken0: selectedPool?.token0,
		poolToken1: selectedPool?.token1,
		currentChainId: currentChainId
	})
	
	const tokenXBalance = useTokenBalanceByAddress(
		userWalletAddress,
		finalTokenXAddress as `0x${string}`,
	)
	const tokenYBalance = useTokenBalanceByAddress(
		userWalletAddress,
		finalTokenYAddress as `0x${string}`,
	)
	
	// üö® Debug: Log balances with correct decimals
	const getTokenDecimals = (symbol: string): number => {
		const tokens = getTokensForChain(currentChainId)
		const token = tokens.find(t => t.symbol === symbol)
		
		if (token?.decimals) {
			console.log(`üîç Found decimals for ${symbol}:`, token.decimals)
			return token.decimals
		}
		
		// Fallback 
		const fallbackDecimals = ['USDT', 'USDC'].includes(symbol.toUpperCase()) ? 6 : 18
		console.log(`üîç Using fallback ${fallbackDecimals} decimals for ${symbol}`)
		return fallbackDecimals
	}
	
	console.log('üí∞ Token Balances Debug:', {
		tokenXBalance: tokenXBalance,
		tokenYBalance: tokenYBalance,
		tokenXDecimals: getTokenDecimals(selectedPool?.token0 || ''),
		tokenYDecimals: getTokenDecimals(selectedPool?.token1 || ''),
		tokenXFormatted: tokenXBalance ? ethers.formatUnits(tokenXBalance, getTokenDecimals(selectedPool?.token0 || '')) : 'undefined',
		tokenYFormatted: tokenYBalance ? ethers.formatUnits(tokenYBalance, getTokenDecimals(selectedPool?.token1 || '')) : 'undefined',
		finalAddresses: { finalTokenXAddress, finalTokenYAddress }
	})

	// Map strategy to single-sided strategy
	const getSingleSidedStrategy = (strategy: LiquidityStrategy): 'conservative' | 'balanced' | 'aggressive' => {
		switch (strategy) {
			case 'curve': return 'conservative'
			case 'spot': return 'balanced'
			case 'bid-ask': return 'aggressive'
			default: return 'balanced'
		}
	}

	const handleAddLiquidity = async (
		amount0: string,
		amount1: string,
		strategy: LiquidityStrategy,
		// üéØ Êñ∞Â¢ûÔºöÊé•Êî∂ÂâçÁ´ØËÆ°ÁÆóÁöÑ‰ª∑Ê†ºËåÉÂõ¥ÂèÇÊï∞
		minPrice?: number,
		maxPrice?: number,
		binCount?: number
	) => {
		console.log('üöÄ handleAddLiquidity called')

		if ((!amount0 && !amount1) || !selectedPool) {
			console.error('‚ùå Validation failed: Please enter at least one token amount')
			toast.error('Please enter at least one token amount')
			return
		}

		if (!userWalletAddress) {
			console.error('‚ùå Validation failed: Please connect your wallet')
			toast.error('Please connect your wallet')
			return
		}

		try {
			console.log('‚è≥ Starting liquidity addition process...')
			setIsPending(true)
			setError(null)

			const amt0 = amount0 ? parseFloat(amount0) : 0
			const amt1 = amount1 ? parseFloat(amount1) : 0

			if (amt0 <= 0 && amt1 <= 0) {
				console.error('‚ùå Amount validation failed: Please enter at least one valid amount')
				toast.error('Please enter at least one valid amount')
				return
			}

			// üéØ ‰ΩøÁî®Â∑≤ÁªèËÆ°ÁÆóÂ•ΩÁöÑÊúÄÁªàtokenÂú∞ÂùÄ
			let tokenXAddress = finalTokenXAddress
			let tokenYAddress = finalTokenYAddress
			
			console.log('üéØ ‰ΩøÁî®ÊúÄÁªàtokenÂú∞ÂùÄ:', {
				tokenXAddress,
				tokenYAddress,
				Êù•Ê∫ê: {
					fromPool: {
						tokenXAddress: selectedPool.tokenXAddress,
						tokenYAddress: selectedPool.tokenYAddress
					},
					fromNetworkConfig: {
						token0Symbol: selectedPool.token0,
						token1Symbol: selectedPool.token1,
						token0Address: getTokenAddress(selectedPool.token0),
						token1Address: getTokenAddress(selectedPool.token1)
					}
				}
			})

			if (!tokenXAddress || !tokenYAddress) {
				console.error('‚ùå Token addresses not found in pool data')
				toast.error('Token addresses not found in pool data')
				return
			}

			if (!tokenXAddress.startsWith('0x') || !tokenYAddress.startsWith('0x')) {
				console.error('‚ùå Invalid address format:', { tokenXAddress, tokenYAddress })
				toast.error('Invalid token address format')
				return
			}

			const pairAddress = selectedPool.pairAddress || selectedPool.id

			if (!pairAddress) {
				console.error('‚ùå Pair address is undefined')
				toast.error('Pool pair address not found')
				return
			}

			// Get current active bin ID
			const publicClient = createViemClient(currentChainId)
			const currentActiveBinId = await publicClient.readContract({
				address: pairAddress as `0x${string}`,
				abi: [{
					inputs: [],
					name: 'getActiveId',
					outputs: [{ internalType: 'uint24', name: '', type: 'uint24' }],
					stateMutability: 'view',
					type: 'function'
				}],
				functionName: 'getActiveId'
			}) as number

			if (!selectedPool.binStep) {
				console.error('‚ùå Bin step not found in selected pool')
				toast.error('Pool bin step not available')
				return
			}

			// Enhanced pre-transaction validation
			const tokenXBal = tokenXBalance ? parseFloat(ethers.formatUnits(tokenXBalance, 18)) : 0
			const tokenYBal = tokenYBalance ? parseFloat(ethers.formatUnits(tokenYBalance, 18)) : 0
			
			if (amt0 > 0 && tokenXBal < amt0) {
				console.error('‚ùå Insufficient Token X balance:', { required: amt0, available: tokenXBal })
				toast.error(`Insufficient ${selectedPool.token0} balance. Required: ${amt0}, Available: ${tokenXBal.toFixed(6)}`)
				return
			}
			
			if (amt1 > 0 && tokenYBal < amt1) {
				console.error('‚ùå Insufficient Token Y balance:', { required: amt1, available: tokenYBal })
				toast.error(`Insufficient ${selectedPool.token1} balance. Required: ${amt1}, Available: ${tokenYBal.toFixed(6)}`)
				return
			}

			// Validate active bin ID
			if (currentActiveBinId < 0 || currentActiveBinId > 16777215) {
				console.error('‚ùå Invalid active bin ID:', currentActiveBinId)
				toast.error('Invalid pool state. Please try a different pool.')
				return
			}

			// Validate bin step
			const supportedBinSteps = [1, 5, 10, 15, 20, 25, 50, 100, 150, 200, 250, 500, 1000]
			if (!supportedBinSteps.includes(selectedPool.binStep)) {
				console.error('‚ùå Unsupported bin step:', selectedPool.binStep)
				toast.error('Unsupported pool bin step.')
				return
			}

			// Validate amounts are not too small
			const minAmount = 0.000001
			if (amt0 > 0 && amt0 < minAmount) {
				console.error('‚ùå Amount0 too small:', amt0)
				toast.error(`${selectedPool.token0} amount too small. Minimum: ${minAmount}`)
				return
			}
			
			if (amt1 > 0 && amt1 < minAmount) {
				console.error('‚ùå Amount1 too small:', amt1)
				toast.error(`${selectedPool.token1} amount too small. Minimum: ${minAmount}`)
				return
			}

			// Verify contract exists
			try {
				await publicClient.readContract({
					address: pairAddress as `0x${string}`,
					abi: [{
						inputs: [],
						name: 'getActiveId',
						outputs: [{ internalType: 'uint24', name: '', type: 'uint24' }],
						stateMutability: 'view',
						type: 'function'
					}],
					functionName: 'getActiveId'
				})
				console.log('‚úÖ Pair contract is valid and responsive')
			} catch (contractError) {
				console.error('‚ùå Pair contract validation failed:', contractError)
				toast.error('Invalid pool contract. Please try a different pool.')
				return
			}

			// Smart detection for single-sided liquidity
			const isSingleSided = amt0 === 0 || amt1 === 0
			const mappedSingleSidedStrategy = getSingleSidedStrategy(strategy)

			// üéØ ËÆ°ÁÆó deltaIds, distributionX, distributionY Âü∫‰∫é‰ª∑Ê†ºËåÉÂõ¥
			let deltaIds: number[] | undefined
			let distributionX: bigint[] | undefined
			let distributionY: bigint[] | undefined

			if (minPrice && maxPrice && binCount) {
				console.log('üéØ ‰ΩøÁî®ÂâçÁ´Ø‰ª∑Ê†ºËåÉÂõ¥ËÆ°ÁÆóÂàÜÂ∏É:', {
					minPrice,
					maxPrice,
					binCount,
					currentActiveBinId,
					binStep: selectedPool.binStep,
					isSingleSided,
					tokenAmounts: { amt0, amt1 }
				})

				// ‰ΩøÁî®LB SDKÁöÑ getUniformDistributionFromBinRange Êù•ËÆ°ÁÆóbin IDs
				try {
					// üéØ ‰ΩøÁî® LB SDK ÁöÑ getUniformDistributionFromBinRange - ÁÆÄÂçïÁõ¥Êé•
					console.log('üéØ ‰ΩøÁî® LB SDK getUniformDistributionFromBinRange:', {
						minPrice,
						maxPrice,
						binCount,
						currentActiveBinId,
						binStep: selectedPool.binStep
					})
					
					// LBÂçèËÆÆÁöÑ‰ª∑Ê†ºÂà∞binIdËΩ¨Êç¢ÂÖ¨Âºè
					const binStepDecimal = selectedPool.binStep / 10000
					
					// ËÆ°ÁÆóminPriceÂíåmaxPriceÂØπÂ∫îÁöÑbinId
					const BASE_BIN_ID = 8388608 // 2^23, binId when price = 1
					let minBinId = Math.round(Math.log(minPrice) / Math.log(1 + binStepDecimal) + BASE_BIN_ID)
					let maxBinId = Math.round(Math.log(maxPrice) / Math.log(1 + binStepDecimal) + BASE_BIN_ID)
					
					// üéØ ÈíàÂØπÂçïËæπÊµÅÂä®ÊÄßË∞ÉÊï¥binËåÉÂõ¥
					if (isSingleSided) {
						if (amt0 > 0 && amt1 === 0) {
							// Token0 ÂçïËæπÊµÅÂä®ÊÄß - Âè™‰ΩøÁî®ÂΩìÂâçbinÂèä‰ª•‰∏äÁöÑbins (deltaIds >= 0)
							minBinId = currentActiveBinId  // ‰ªéÂΩìÂâçbinÂºÄÂßã
							maxBinId = Math.max(maxBinId, currentActiveBinId + 20) // Ëá≥Â∞ëÂêëÂè≥Êâ©Â±ï20‰∏™bins
						} else if (amt1 > 0 && amt0 === 0) {
							// Token1 ÂçïËæπÊµÅÂä®ÊÄß - Âè™‰ΩøÁî®ÂΩìÂâçbinÂèä‰ª•‰∏ãÁöÑbins (deltaIds <= 0)
							minBinId = Math.min(minBinId, currentActiveBinId - 20) // Ëá≥Â∞ëÂêëÂ∑¶Êâ©Â±ï20‰∏™bins
							maxBinId = currentActiveBinId  // Âà∞ÂΩìÂâçbinÁªìÊùü
						}
					}
					
					console.log('üîç ‰ª∑Ê†ºËåÉÂõ¥ÂØπÂ∫îÁöÑbinId:', {
						minPrice,
						maxPrice,
						minBinId,
						maxBinId,
						binRange: maxBinId - minBinId + 1
					})
					
					// üéØ Áõ¥Êé•‰ΩøÁî® LB SDK ÁöÑ getUniformDistributionFromBinRange
					const binRange: [number, number] = [minBinId, maxBinId]
					
					const result = getUniformDistributionFromBinRange(
						currentActiveBinId,
						binRange
					)
					
					deltaIds = result.deltaIds
					distributionX = result.distributionX
					distributionY = result.distributionY
					
					console.log('üéØ LB SDK ÁîüÊàêÁöÑÂàÜÂ∏ÉÂèÇÊï∞:', {
						deltaIds,
						distributionX: distributionX?.map(d => d.toString()),
						distributionY: distributionY?.map(d => d.toString()),
						distributionXSum: distributionX?.reduce((sum, val) => sum + val, BigInt(0)).toString(),
						distributionYSum: distributionY?.reduce((sum, val) => sum + val, BigInt(0)).toString(),
						binRange,
						tokenAmounts: { amt0, amt1 }
					})

					// üö® ÂÖ≥ÈîÆÈ™åËØÅÔºöÁ°Æ‰øùÂàÜÂ∏ÉÊï∞ÁªÑÈïøÂ∫¶ÂíådeltaIdsÂåπÈÖç
					if (distributionX && distributionY && deltaIds) {
						const deltaIdsLength = deltaIds.length
						const distXLength = distributionX.length
						const distYLength = distributionY.length
						
						if (deltaIdsLength !== distXLength || deltaIdsLength !== distYLength) {
							console.error('‚ùå Êï∞ÁªÑÈïøÂ∫¶‰∏çÂåπÈÖç:', {
								deltaIdsLength,
								distXLength,
								distYLength
							})
							throw new Error('Distribution arrays length mismatch with deltaIds')
						}
						
						// È™åËØÅÊÄªÂíå - LB SDK ‰ΩøÁî®Êõ¥È´òÁ≤æÂ∫¶ÁöÑÂü∫Êï∞ (10^18 instead of 10^4)
						const sumX = distributionX.reduce((sum, val) => sum + val, BigInt(0))
						const sumY = distributionY.reduce((sum, val) => sum + val, BigInt(0))
						
						// LB SDK ‰ΩøÁî® 10^18 ‰Ωú‰∏∫Âü∫Êï∞ÔºåËÄå‰∏çÊòØ 10000
						const expectedTotal = BigInt('1000000000000000000') // 10^18
						const tolerance = BigInt('100000000000000000') // 10% tolerance for precision (SDK rounding)
						
						const isWithinTolerance = (value: bigint, expected: bigint) => {
							const diff = value > expected ? value - expected : expected - value
							return diff <= tolerance
						}
						
						if (isSingleSided) {
							// ÂçïËæπÊµÅÂä®ÊÄßÔºöÊ£ÄÊü•Âì™‰∏™tokenÊúâÈáëÈ¢ùÔºåÂØπÂ∫îÁöÑÂàÜÂ∏ÉÂ∫îËØ•Êé•Ëøë10^18
							if (amt0 > 0 && amt1 === 0) {
								// Token0 (X) ÂçïËæπÊµÅÂä®ÊÄß - distributionXÂ∫îËØ•Êé•Ëøë10^18
								if (!isWithinTolerance(sumX, expectedTotal)) {
									console.error('‚ùå ÂçïËæπXÊµÅÂä®ÊÄßÂàÜÂ∏ÉÈîôËØØ:', { sumX: sumX.toString(), sumY: sumY.toString(), expected: expectedTotal.toString() })
									throw new Error('Single-sided X liquidity distribution error')
								}
							} else if (amt1 > 0 && amt0 === 0) {
								// Token1 (Y) ÂçïËæπÊµÅÂä®ÊÄß - distributionYÂ∫îËØ•Êé•Ëøë10^18
								if (!isWithinTolerance(sumY, expectedTotal)) {
									console.error('‚ùå ÂçïËæπYÊµÅÂä®ÊÄßÂàÜÂ∏ÉÈîôËØØ:', { sumX: sumX.toString(), sumY: sumY.toString(), expected: expectedTotal.toString() })
									throw new Error('Single-sided Y liquidity distribution error')
								}
							}
						} else {
							// ÂèåËæπÊµÅÂä®ÊÄßÔºö‰∏§‰∏™ÈÉΩÂ∫îËØ•Êé•Ëøë10^18
							if (!isWithinTolerance(sumX, expectedTotal) || !isWithinTolerance(sumY, expectedTotal)) {
								console.error('‚ùå ÂèåËæπÊµÅÂä®ÊÄßÂàÜÂ∏ÉÈîôËØØ:', { sumX: sumX.toString(), sumY: sumY.toString(), expected: expectedTotal.toString() })
								throw new Error('Dual-sided liquidity distribution error')
							}
						}
					}

					console.log('üéØ ËÆ°ÁÆóÂÆåÊàêÁöÑÂàÜÂ∏ÉÂèÇÊï∞ (È™åËØÅÈÄöËøá):', {
						deltaIds,
						distributionX: distributionX?.map(d => d.toString()),
						distributionY: distributionY?.map(d => d.toString()),
						distributionXSum: distributionX?.reduce((sum, val) => sum + val, BigInt(0)).toString(),
						distributionYSum: distributionY?.reduce((sum, val) => sum + val, BigInt(0)).toString(),
						isSingleSided,
						tokenAmounts: { amt0, amt1 },
						// üîç È¢ùÂ§ñË∞ÉËØï‰ø°ÊÅØ
						activeBinPosition: deltaIds?.indexOf(0), // ÂΩìÂâç‰ª∑Ê†ºÂú®Êï∞ÁªÑ‰∏≠ÁöÑ‰ΩçÁΩÆ
						binRange: [minBinId, maxBinId],
						activeBinId: currentActiveBinId
					})

				} catch (priceCalcError) {
					console.error('‚ùå ‰ª∑Ê†ºËåÉÂõ¥ËÆ°ÁÆóÂ§±Ë¥•:', priceCalcError)
					// ÂõûÈÄÄÂà∞undefinedÔºåËÆ©useDexOperations‰ΩøÁî®ÈªòËÆ§ÈÄªËæë
					deltaIds = undefined
					distributionX = undefined
					distributionY = undefined
				}
			}

			// üö® ÊúÄÁªàÂèÇÊï∞È™åËØÅÂíåÊó•Âøó
			console.log('üéØ Âç≥Â∞ÜË∞ÉÁî®addLiquidityÔºåÊúÄÁªàÂèÇÊï∞:', {
				pairAddress,
				tokenXAddress,
				tokenYAddress,
				amt0,
				amt1,
				currentActiveBinId,
				binStep: selectedPool.binStep,
				deltaIds,
				distributionX: distributionX?.map(d => d.toString()),
				distributionY: distributionY?.map(d => d.toString()),
				isSingleSided,
				strategy: isSingleSided ? mappedSingleSidedStrategy : undefined,
				slippageTolerance
			})

			// üéØ ‰∏¥Êó∂ÊµãËØïÔºöÂÖàÁî®undefinedËÆ©ÂêéÁ´ØÁîüÊàêÈªòËÆ§ÂàÜÂ∏ÉÔºåÂØπÊØîÂ∑ÆÂºÇ
			console.log('üîç ÊµãËØïÔºö‰ΩøÁî®fallbackÂèÇÊï∞ (ËÆæÁΩÆ‰∏∫undefined)')

			await addLiquidity(
				pairAddress,
				tokenXAddress,
				tokenYAddress,
				amt0,
				amt1,
				currentActiveBinId,
				selectedPool.binStep,
				deltaIds, // üéØ ‰ΩøÁî®ËÆ°ÁÆóÁöÑdeltaIds
				distributionX, // üéØ ‰ΩøÁî®ËÆ°ÁÆóÁöÑdistributionX
				distributionY, // üéØ ‰ΩøÁî®ËÆ°ÁÆóÁöÑdistributionY
				isSingleSided,
				isSingleSided ? mappedSingleSidedStrategy : undefined,
				slippageTolerance
			)

			console.log('‚úÖ Liquidity added successfully!')
			toast.success('Liquidity added successfully!')
			setIsSuccess(true)
			if (onSuccess) {
				onSuccess()
			}
		} catch (err: unknown) {
			console.error('üí• Add liquidity error:', err)
			const error = err instanceof Error ? err : new Error('Unknown error occurred')
			
			// Enhanced error detection
			let errorMessage = 'Failed to add liquidity'
			
			if (error.message.includes('User rejected') || error.message.includes('user denied')) {
				errorMessage = 'Transaction was cancelled by user'
			} else if (error.message.includes('insufficient funds') || error.message.includes('insufficient balance')) {
				errorMessage = 'Insufficient funds for transaction'
			} else if (error.message.includes('allowance') || error.message.includes('ERC20: transfer amount exceeds allowance')) {
				errorMessage = 'Token allowance insufficient. Please approve tokens first.'
			} else if (error.message.includes('LBRouter__AmountSlippageCaught')) {
				const match = error.message.match(/LBRouter__AmountSlippageCaught \(amountXMin=(\d+), amountX=(\d+), amountYMin=(\d+), amountY=(\d+)/)
				if (match) {
					const [, amountXMin, amountX, amountYMin, amountY] = match
					errorMessage = `Price slippage protection triggered. Expected minimum: X=${amountXMin}, Y=${amountYMin}, but got: X=${amountX}, Y=${amountY}. Please try again when market conditions are more stable, or try with smaller amounts.`
				} else {
					errorMessage = 'Price slippage too high. The price moved significantly during transaction. Please try again with higher slippage tolerance or when markets are less volatile.'
				}
			} else if (error.message.includes('execution reverted')) {
				if (error.message.includes('INSUFFICIENT_AMOUNT') || error.message.includes('InsufficientAmount')) {
					errorMessage = 'Insufficient token amount. Try increasing the amount.'
				} else if (error.message.includes('INSUFFICIENT_LIQUIDITY') || error.message.includes('InsufficientLiquidity')) {
					errorMessage = 'Insufficient liquidity in the pool. Try a different amount.'
				} else {
					errorMessage = 'Transaction failed (execution reverted). Please check your inputs and try again.'
				}
			} else if (error.message.includes('gas')) {
				errorMessage = 'Transaction failed due to gas issues. Try increasing gas limit.'
			} else if (error.message.includes('network') || error.message.includes('connection')) {
				errorMessage = 'Network connection error. Please check your connection and try again.'
			} else if (error.message) {
				errorMessage = error.message
			}
			
			toast.error(errorMessage)
			setError(error)
		} finally {
			setIsPending(false)
		}
	}

	return {
		isPending,
		isSuccess,
		error,
		slippageTolerance,
		tokenXBalance,
		tokenYBalance,
		userWalletAddress,
		handleAddLiquidity,
	}
}
